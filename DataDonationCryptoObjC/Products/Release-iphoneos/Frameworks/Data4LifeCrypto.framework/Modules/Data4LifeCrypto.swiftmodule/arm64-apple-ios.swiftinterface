// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4 (swiftlang-1205.0.26.9 clang-1205.0.19.55)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Data4LifeCrypto
import CommonCrypto
import CryptoKit
@_exported import Data4LifeCrypto
import Foundation
import Swift
extension KeyPair : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension KeyPair : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
public enum KeyType : Swift.String, Swift.CaseIterable {
  case tag
  case common
  case data
  case attachment
  case appPrivate
  case appPublic
  public init?(rawValue: Swift.String)
  public typealias AllCases = [Data4LifeCrypto.KeyType]
  public typealias RawValue = Swift.String
  public static var allCases: [Data4LifeCrypto.KeyType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum AsymmetricKeyType : Swift.String {
  case `public`
  case `private`
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct AsymmetricKey {
  public let value: Security.SecKey
  public let type: Data4LifeCrypto.AsymmetricKeyType
  public func asData() throws -> Foundation.Data
  public func asBase64EncodedString() throws -> Swift.String
  public func asSPKIBase64EncodedString() throws -> Swift.String
}
public struct Key {
  public let value: Foundation.Data
  public var algorithm: Data4LifeCrypto.AlgorithmType
  public let keySize: Data4LifeCrypto.KeySize
  public let type: Data4LifeCrypto.KeyType
  public static func generate(keySize: Data4LifeCrypto.KeySize, algorithm: Data4LifeCrypto.AlgorithmType, type: Data4LifeCrypto.KeyType) throws -> Data4LifeCrypto.Key
}
extension Key : Swift.Equatable {
  public static func == (lhs: Data4LifeCrypto.Key, rhs: Data4LifeCrypto.Key) -> Swift.Bool
}
extension Key {
  public var ivSize: Swift.Int {
    get
  }
}
public protocol InitializationVectorGeneratorProtocol {
  func randomIVData(of size: Swift.Int) -> Foundation.Data
}
final public class InitializationVectorGenerator : Data4LifeCrypto.InitializationVectorGeneratorProtocol {
  public init()
  final public func randomIVData(of size: Swift.Int) -> Foundation.Data
  @objc deinit
}
public protocol CryptorProtocol {
  static func symEncrypt(key: Data4LifeCrypto.Key, data: Foundation.Data, iv: Foundation.Data) throws -> Foundation.Data
  static func symDecrypt(key: Data4LifeCrypto.Key, data: Foundation.Data, iv: Foundation.Data) throws -> Foundation.Data
  static func asymEncrypt(key: Data4LifeCrypto.KeyPair, data: Foundation.Data) throws -> Foundation.Data
  static func asymDecrypt(key: Data4LifeCrypto.KeyPair, data: Foundation.Data) throws -> Foundation.Data
  static func generateAsymKeyPair(algorithm: Data4LifeCrypto.AlgorithmType, options: Data4LifeCrypto.KeyOptions) throws -> Data4LifeCrypto.KeyPair
  static func generateSymKey(algorithm: Data4LifeCrypto.AlgorithmType, options: Data4LifeCrypto.KeyOptions, type: Data4LifeCrypto.KeyType) throws -> Data4LifeCrypto.Key
}
public struct Data4LifeCryptor : Data4LifeCrypto.CryptorProtocol {
  public static func symEncrypt(key: Data4LifeCrypto.Key, data: Foundation.Data, iv: Foundation.Data) throws -> Foundation.Data
  public static func symDecrypt(key: Data4LifeCrypto.Key, data: Foundation.Data, iv: Foundation.Data) throws -> Foundation.Data
  public static func asymEncrypt(key: Data4LifeCrypto.KeyPair, data: Foundation.Data) throws -> Foundation.Data
  public static func asymDecrypt(key: Data4LifeCrypto.KeyPair, data: Foundation.Data) throws -> Foundation.Data
  public static func generateAsymKeyPair(algorithm: Data4LifeCrypto.AlgorithmType, options: Data4LifeCrypto.KeyOptions) throws -> Data4LifeCrypto.KeyPair
  public static func generateSymKey(algorithm: Data4LifeCrypto.AlgorithmType, options: Data4LifeCrypto.KeyOptions, type: Data4LifeCrypto.KeyType) throws -> Data4LifeCrypto.Key
}
public typealias KeySize = Swift.Int
public struct KeyOptions {
  public let size: Data4LifeCrypto.KeySize
  public let tag: Swift.String?
  public init(size: Data4LifeCrypto.KeySize, tag: Swift.String? = nil)
}
public struct RSAAlgorithm : Data4LifeCrypto.AlgorithmType {
  public var cipher: Data4LifeCrypto.CipherType
  public var padding: Data4LifeCrypto.Padding
  public var blockMode: Data4LifeCrypto.BlockMode?
  public var hash: Data4LifeCrypto.HashType?
  public var iv: Swift.String?
  public init()
}
public enum Data4LifeCryptoError : Foundation.LocalizedError {
  case couldNotReadPublicKey
  case couldNotReadPrivateKey
  case couldNotReadKeyAttributes
  case couldNotReadKeySize
  case couldNotReadBase64EncodedData
  case couldNotReadKeyPair(Swift.String)
  case couldNotDeleteKeyPair(Swift.String)
  case couldNotCopySecureRandomBytes
  case couldNotEncryptData
  case couldNotDecryptData
  case keyDoesNotMatchExpectedSize
  case keyIsNotRSAKey
  case keyIsNotPublicKey
  case invalidKeyType(Swift.String)
  case invalidKeyAlgorithmVersion(Swift.String)
  case missingHeaderBytesForKeySize(Swift.Int)
  case missingKeyPairTagOption
  case unsupportedAlgorithmCombination
}
extension Data4LifeCryptoError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Data4LifeCryptoError {
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
  public var recoverySuggestion: Swift.String? {
    get
  }
}
extension Data4LifeCryptoError : Swift.Equatable {
  public static func == (lhs: Data4LifeCrypto.Data4LifeCryptoError, rhs: Data4LifeCrypto.Data4LifeCryptoError) -> Swift.Bool
  public static func == (lhs: Swift.Error, rhs: Data4LifeCrypto.Data4LifeCryptoError) -> Swift.Bool
}
public typealias KeyExchangeFormat = (algorithm: Data4LifeCrypto.AlgorithmType, size: Data4LifeCrypto.KeySize)
public struct KeyExhangeFactory {
  public static func create(type: Data4LifeCrypto.KeyType, version: Swift.Int = 1) throws -> Data4LifeCrypto.KeyExchangeFormat
}
public protocol KeyPairType {
  var publicKey: Data4LifeCrypto.AsymmetricKey { get }
  var privateKey: Data4LifeCrypto.AsymmetricKey { get }
  var algorithm: Data4LifeCrypto.AlgorithmType { get }
  var keySize: Data4LifeCrypto.KeySize { get }
  static func generate(tag: Swift.String, keySize: Swift.Int, algorithm: Data4LifeCrypto.AlgorithmType) throws -> Self
  static func load(tag: Swift.String, algorithm: Data4LifeCrypto.AlgorithmType) throws -> Self
  static func destroy(tag: Swift.String) throws
}
public struct KeyPair : Data4LifeCrypto.KeyPairType {
  public let privateKey: Data4LifeCrypto.AsymmetricKey
  public let publicKey: Data4LifeCrypto.AsymmetricKey
  public let keySize: Data4LifeCrypto.KeySize
  public let algorithm: Data4LifeCrypto.AlgorithmType
  public static func load(tag: Swift.String, algorithm: Data4LifeCrypto.AlgorithmType) throws -> Data4LifeCrypto.KeyPair
  public static func destroy(tag: Swift.String) throws
  public static func generate(tag: Swift.String, keySize: Swift.Int, algorithm: Data4LifeCrypto.AlgorithmType) throws -> Data4LifeCrypto.KeyPair
}
public protocol AlgorithmType {
  var cipher: Data4LifeCrypto.CipherType { get }
  var padding: Data4LifeCrypto.Padding { get }
  var blockMode: Data4LifeCrypto.BlockMode? { get }
  var hash: Data4LifeCrypto.HashType? { get }
}
public enum BlockMode : Swift.String, Swift.CaseIterable {
  case cbc
  case gcm
  public init?(rawValue: Swift.String)
  public typealias AllCases = [Data4LifeCrypto.BlockMode]
  public typealias RawValue = Swift.String
  public static var allCases: [Data4LifeCrypto.BlockMode] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum CipherType : Swift.String, Swift.CaseIterable {
  case aes
  case rsa
  public init?(rawValue: Swift.String)
  public typealias AllCases = [Data4LifeCrypto.CipherType]
  public typealias RawValue = Swift.String
  public static var allCases: [Data4LifeCrypto.CipherType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum Padding : Swift.String, Swift.CaseIterable {
  case noPadding
  case pkcs1
  case pkcs5
  case pkcs7
  case oaep
  public init?(rawValue: Swift.String)
  public typealias AllCases = [Data4LifeCrypto.Padding]
  public typealias RawValue = Swift.String
  public static var allCases: [Data4LifeCrypto.Padding] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum HashType : Swift.String, Swift.CaseIterable {
  case sha256
  public init?(rawValue: Swift.String)
  public typealias AllCases = [Data4LifeCrypto.HashType]
  public typealias RawValue = Swift.String
  public static var allCases: [Data4LifeCrypto.HashType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension Key : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension Key : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
public typealias Byte = (Swift.UInt8)
extension Array where Element == Data4LifeCrypto.Byte {
  public var asData: Foundation.Data {
    get
  }
}
extension Data {
  public var asBytes: [Swift.UInt8] {
    get
  }
  public var byteCount: Swift.Int {
    get
  }
}
extension Data4LifeCrypto.KeyType : Swift.Equatable {}
extension Data4LifeCrypto.KeyType : Swift.Hashable {}
extension Data4LifeCrypto.KeyType : Swift.RawRepresentable {}
extension Data4LifeCrypto.AsymmetricKeyType : Swift.Equatable {}
extension Data4LifeCrypto.AsymmetricKeyType : Swift.Hashable {}
extension Data4LifeCrypto.AsymmetricKeyType : Swift.RawRepresentable {}
extension Data4LifeCrypto.BlockMode : Swift.Equatable {}
extension Data4LifeCrypto.BlockMode : Swift.Hashable {}
extension Data4LifeCrypto.BlockMode : Swift.RawRepresentable {}
extension Data4LifeCrypto.CipherType : Swift.Equatable {}
extension Data4LifeCrypto.CipherType : Swift.Hashable {}
extension Data4LifeCrypto.CipherType : Swift.RawRepresentable {}
extension Data4LifeCrypto.Padding : Swift.Equatable {}
extension Data4LifeCrypto.Padding : Swift.Hashable {}
extension Data4LifeCrypto.Padding : Swift.RawRepresentable {}
extension Data4LifeCrypto.HashType : Swift.Equatable {}
extension Data4LifeCrypto.HashType : Swift.Hashable {}
extension Data4LifeCrypto.HashType : Swift.RawRepresentable {}
